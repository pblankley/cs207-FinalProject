
import numpy as np
from functools import reduce
import os
import xml.etree.ElementTree as ET


class Reaction:
    """
    This class represents the entire reaction for a set of elementary reactions.
    The class takes in a dictionary of parameters generated by the parser function.
    
    This dictionary contains a matrix vprime and a matrix v2prime corresponding to
    the usual v' and v'' matrices in systems of elementary reactions, v' being reactants 
    and v'' being reactants.
    
    The dictionary also contains lists (length corresponding to the columns of v' and v'')
    with the values for A,b,E,k and coeftype for each elementary reaction in the system. NOTE: If one 
    or more of these parameters is rendered useless or NA for a reaction it is given the
    value NaN. Coeftype is a list of strings containing the type of reaction.
    
    ----------
    Args: param_dict; where param_dict is the output from the parser function.
    
    ----------
    Methods: 
        reaction_coef(Temperature); Returns the 'k' reaction coefficients for 
                                    each reaction in the system
        
        progress_rate(x, T); where x is the vector of concentrations of the system and 
                            T is the temperature the system of reactions occurs at. Returns
                            the 'w' progress rate for each reaction in the system.
        
        reaction_rate(x, T); where x is the vector of concentrations of the system and 
                            T is the temperature the system of reactions occurs at. Returns
                            the 'f' reaction rate for each reaction in the system.
        set_params(idx, **kwargs); where you specify idx to be the index of the reaction 
                            you want to change the parameters for and the keyword 
                            indicates the parameter you want to change. 
                            Options to change are: {A,b,E,R,k,coeftype}
    =========
    Examples:
    # Example with the reaction rate
        
    >>> vp = np.array([[1.,2.],[2.,0.],[0.,2.]])
    >>> vpp = np.array([[0.,0.],[0.,1.],[2.,1.]])
    >>> pdict = {'vprime': vp, 'v2prime': vpp, 'A': [float('nan'),float('nan')], \
                'b': [float('nan'),float('nan')], 'E': [float('nan'),float('nan')], \
                'k': [10,10], 'coeftype': ['Constant','Constant']}
    >>> rrr = Reaction(pdict)
    >>> rrr.reaction_rate(np.array([[1.],[2.],[1.]]),10)
    [-60.0, -70.0, 70.0]
    
    # Example with the progress rate 
    
    >>> vp = np.array([[1.,2.],[2.,0.],[0.,2.]])
    >>> vpp = np.array([[0.,0.],[0.,1.],[2.,1.]])
    >>> pdict = {'vprime': vp, 'v2prime': vpp, 'A': [float('nan'),float('nan')], \
                'b': [float('nan'),float('nan')], 'E': [float('nan'),float('nan')], \
                'k': [10,10], 'coeftype': ['Constant','Constant']}
    >>> rrr = Reaction(pdict)
    >>> rrr.progress_rate(np.array([[1.],[2.],[1.]]),10)
    [40.0, 10.0]
    
    # Example with reaction coef 
    
    >>> vp = np.array([[1.,2.],[2.,0.],[0.,2.]])
    >>> vpp = np.array([[0.,0.],[0.,1.],[2.,1.]])
    >>> pdict = {'vprime': vp, 'v2prime': vpp, 'A': [.00045,.00045], \
                'b': [1.2,1.2], 'E': [1.7,1.7], \
                'k': [float('nan'),float('nan')], 'coeftype': ['Arrhenius','modifiedArrhenius']}
    >>> rrr = Reaction(pdict)
    >>> rrr.reaction_coef(900)
    [0.00044989777442266471, 1.5783556022951033]
    
    # Example with set params
    
    >>> vp = np.array([[1.,2.],[2.,0.],[0.,2.]])
    >>> vpp = np.array([[0.,0.],[0.,1.],[2.,1.]])
    >>> pdict = {'vprime': vp, 'v2prime': vpp, 'A': [.00045,.00045], \
                'b': [1.2,1.2], 'E': [1.7,1.7], \
                'k': [float('nan'),float('nan')], 'coeftype': ['Arrhenius','modifiedArrhenius']}
    >>> rrr = Reaction(pdict)
    >>> w = rrr.reaction_coef(900)
    >>> ww = rrr.set_params(1,k=10, coeftype='Constant')
    >>> rrr.reaction_coef(900)
    [0.00044989777442266471, 10.0]
    
    """
    def __init__(self, param_dict):
        self.vprime = param_dict['vprime']
        self.v2prime = param_dict['v2prime']
        self.species = param_dict['species']

        # Check for equal shapes in v' and v''
        if self.vprime.shape!=self.v2prime.shape:
            raise ValueError('The vprime and v2prime matrices must be the same size.')
        
        # Make sure every parameter for A,b,E,k comes in as a float
        try: 
            self.A = [float(a) for a in param_dict['A']]
            self.b = [float(i) for i in param_dict['b']]
            self.E = [float(e) for e in param_dict['E']]
            self.k = [float(j) for j in param_dict['k']]
            self.R = [8.314 for i in range(len(param_dict['A']))]
        except (TypeError, ValueError) as err:
                if type(err) == ValueError:
                    raise ValueError('You must input a numeric, real number data type for all parameters.')
                raise TypeError('You must input a real number. Hint: you may have put in a list.')
        
        # All A values must be ge 0
        if any(a<=0 for a in self.A):
            raise ValueError('Your A values should be strictly positive. They were {self.A}.')
        
        # Validate input model types
        valid_types = ['modifiedArrhenius','Arrhenius','Constant']
        if all(pt in valid_types for pt in param_dict['coeftype']):
            self.coeftypes = param_dict['coeftype']
        else:
            raise ValueError("Your input file gave, {param_dict['coeftype']}, not valid reaction coefficients type.")
    
    
    
    def reaction_coef(self, T):
        """Set reaction coefficients for the given float T and mt (model type).
        -------
        Args: T; float; the temperature for all reactions
              mt; list of strings, the model types for each part of the reaction
        -------
        Returns: None
        -------
        Raises: ValueError when T cannot be cast to a float or T is negative 
        """
        try:
            temp = float(T)
        except (TypeError, ValueError) as err:
            raise err('Your value for temp must be a float, not {T}')
        
        if temp < 0:
            raise ValueError('Your T value should be positive. It was {temp}.')
            
        for i,mt in enumerate(self.coeftypes):
            if mt == 'Constant':
                pass
            elif mt == 'Arrhenius':
                self.k[i] = self._arrhenius(i,temp)
            else: 
                self.k[i] = self._mod_arrhenius(i,temp)
        return self.k
        
        
    def progress_rate(self, x, T):
        """ This function calculates the progress rate of a reaction of the following form:
                    V'11*A + V'21*B -> V''31*C
                V'12*A + V'32*C -> V''22*B + V''32*C
        It taken in the vectors v', v'' and x in the order [[A],[B],[C]].
        -------
        Args: v',v'', matrices, numpy arrays of form mxn where m is the number of reactants and n is number of equations.
              x; vector, numpy array (or list of lists) of length equal to the number of reactants in the system of equations.
              k; float or list of length n (number of equations), the k constant in the reaction of elementary equations.
        -------
        Returns: list of floats; the progress rate of the reaction for each equation
        -------
        Raises: ValueError if the shapes of the v matrices are not equal and if the x vector is not mx1
        =======
        
        Doctest for this method in class 
        
        """
        m,n = self.vprime.shape
        if x.shape != (m,1):
            raise ValueError('The x vector must be the same height as your v matrices, but it was {x.shape[0]}')
        
        try:
            temp = float(T)
        except (TypeError, ValueError) as err:
            raise err('Your value for temp must be a float, not {T}')
        
        if temp < 0:
            raise ValueError('Your T value should be positive. It was {temp}.')
            
        k = self.reaction_coef(temp)
        w = []
        for j in range(n):
            w.append(k[j]*reduce((lambda x,y: x*y),np.power(x.T[0],self.vprime.T[j])))
        self.w = w
        return w
    
    
    def reaction_rate(self,x,T):
        """ This function calculates the reaction rate of a reaction of the following form:
                    V'11*A + V'21*B -> V''31*C
                    V'32*C -> V'12*A + V''22*B
        It taken in the vectors v', v'' from the class and x in the order [[A],[B],[C]].
        -------
        Args: x; vector, numpy array (or list) of length equal to the number of 
                    reactants in the system of equations.
              T; float, the strictly positive temperature 
        -------
        Returns: vector of floats; the reaction rate for each equation
        -------
        Raises: ValueError when temp is less than 0 or x is not (mx1)
        =======
        
        Doctests for this method in class
    
        """
        m,n = self.vprime.shape

        if x.shape != (m,1):
            raise ValueError('The x vector must be the same height as your v matrices, but it was {x.shape[0]}')
        
        try:
            temp = float(T)
        except (TypeError, ValueError) as err:
            raise ValueError('Your value for temp must be a float, not {T}')
        
        if temp < 0:
            raise ValueError('Your T value should be positive. It was {temp}.')
            
        w = self.progress_rate(x,T)
        v = self.v2prime - self.vprime
        f = []
        for i in range(m):
            f.append(sum([v[i][j]*w[j] for j in range(n)]))
        return f
    
    def _arrhenius(self, idx, T):
        """ This function takes in the parameter T (kelvin temperature)
        from the class attributes, and it will return a value, k, that is the 
        Arrhenius reaction rate coefficient.
        ---------
        Args: T, float; temperature, (gets args from class)
        ---------
        Returns: The float k where k is the reaction rate coefficient.
        ---------
        Raises: OverflowError after constant evaluation
                FloatingPointError after constant evaluation for underflow
        """
        k = self.A[idx]*np.exp(-self.E[idx]/(self.R[idx]*T))
        if k == float('inf'):
            raise OverflowError('overflow error in evaluation of constant')
        if k <= np.finfo(float).eps:
            raise FloatingPointError('underflow error in evaluation of constant')
        return k

    def _mod_arrhenius(self, idx, T):
        """ This function takes in the parameter T (kelvin temperature)
        from the class attributes, and it will return a value, k, that is the 
        modified Arrhenius reaction rate coefficient.
        ---------
        Args: T, float; temperature (gets args from class)
        ---------
        Returns: The float k where k is the reaction rate coefficient.
        ---------
        Raises: OverflowError after constant evaluation
                FloatingPointError after constant evaluation for underflow
        """
        k = self.A[idx]*(T**self.b[idx])*np.exp(-self.E[idx]/(self.R[idx]*T))
        if k == float('inf'):
            raise OverflowError('overflow error in evalutation of constant')
        if k <= np.finfo(float).eps:
            raise FloatingPointError('underflow error in evalutation of constant')
        return k

    def set_params(self,idx,A=None,b=None,E=None,R=None, k=None, coeftype=None):
        """ This function takes inputs of the parameters you want to set for 
        reaction coefficient calculation 
        -------
        Args: A,b,E,T,R; all floats and optional arguments
        -------
        Returns: None
        -------
        Raises: ValueError when any input given a value other than None cannot 
            be cast to a float
        """
        if type(A) != type(None):
            try:
                self.A[idx] = float(A)
            except (TypeError, ValueError) as err:
                if type(err) == ValueError:
                    raise ValueError('Your input  for A was not a numeric, real number.')
                raise TypeError('You must input a real number for A. Hint: you may have put in a list.')
        
        if type(b) != type(None):
            try:
                self.b[idx] = float(b)
            except (TypeError, ValueError) as err:
                if type(err) == ValueError:
                    raise ValueError('Your input  for b was not a numeric, real number.')
                raise TypeError('You must input a real number for b. Hint: you may have put in a list.')
    
        if type(E) != type(None):
            try:
                self.E[idx] = float(E)
            except (TypeError, ValueError) as err:
                if type(err) == ValueError:
                    raise ValueError('Your input  for E was not a numeric, real number.')
                raise TypeError('You must input a real number for E. Hint: you may have put in a list.')

        if type(R) != type(None):
            try:
                self.R[idx] = float(R)
            except (TypeError, ValueError) as err:
                if type(err) == ValueError:
                    raise ValueError('Your input  for R was not a numeric, real number.')
                raise TypeError('You must input a real number for R. Hint: you may have put in a list.')
    
        if type(k) != type(None):
            try:
                self.k[idx] = float(k)
            except (TypeError, ValueError) as err:
                if type(err) == ValueError:
                    raise ValueError('Your input  for R was not a numeric, real number.')
                raise TypeError('You must input a real number for R. Hint: you may have put in a list.')
    
        if type(coeftype) != type(None):
            if coeftype in ['modifiedArrhenius','Arrhenius','Constant']:
                self.coeftypes[idx] = coeftype
            else:
                raise ValueError('Your input for coeftype was {coeftype}, not an available option')


def get_reactions(name):
    """ This function takes in the name of the input xml file, and returns a dictionary of relevant information for
        a set of chemical reactions
    ------
    Args: name: name of the input xml file
    ------
    Returns: reaction_dict, dictionary of data for a reaction.  Contains the following keys:
             reaction_dict['species'] : list of strings, species of the reaction
             reaction_dict['As']: list of floats, corresponding to reaction parameter A for each equation
                                           = NaN for any equations that don't use A.
             reaction_dict['bs']: list of floats, corresponding to reaction parameter b for each equation
                                           = NaN for any equations that don't use b.
             reaction_dict['Es']: list of floats, corresponding to reaction parameter E for each equation
                                           = NaN for any equations that don't use E.
             reaction_dict['ks']: list of floats, corresponding to reaction parameter k for each equation
                                           = NaN for any equations that don't use k (ie, non-constant equations).
             reaction_dict['rxn_types']: List of strings. Elements Correspond to same reactions as reaction_parameters.
                                           Each string is one of { 'Arrhenius', 'modifiedArrhenius', 'Constant' }
             reaction_dict['vprime'] : np array, full vprime matrix of all reactions in the xml file
             reaction_dict['v2prime'] : np array, full v2prime matrix of all reactions in the xml file
    """
    if os.stat(name).st_size == 0:
        raise FileNotFoundError("File is empty.  Hint: Double-check xml file contents")

    reaction_dict = {}
    tree = ET.parse(name)
    chemical_reactions = tree.getroot()
    if chemical_reactions == []:
        raise ValueError('Unable to locate reaction data in xml')

    # Get the list and number of species
    species_list = []
    for ele in chemical_reactions.iter('phase'):
        for e in ele.find('speciesArray').text.split():
            species_list.append(e)
    reaction_dict['species'] = np.array(species_list)
    if species_list == []:
        raise ValueError('Invalid species list in xml')

    # Get the reaction rate types and parameters for each reaction
    As, bs, Es, ks = [], [], [], []
    rxn_types = []

    reactions_list = chemical_reactions.find('reactionData').findall('reaction')
    if reactions_list == []:
        raise ValueError('Invalid reactions list in xml')

    for reaction_data in reactions_list:
        for coeff_set in reaction_data.find('rateCoeff'):
            rxn_types.append(coeff_set.tag)
            if coeff_set.tag == 'Arrhenius':
                As.append(float(coeff_set.find('A').text))
                bs.append(float('nan'))
                Es.append(float(coeff_set.find('E').text))
                ks.append(float('nan'))
            elif coeff_set.tag == 'modifiedArrhenius':
                As.append(float(coeff_set.find('A').text))
                bs.append(float(coeff_set.find('b').text))
                Es.append(float(coeff_set.find('E').text))
                ks.append(float('nan'))
            elif coeff_set.tag == 'Constant':
                As.append(float('nan'))
                bs.append(float('nan'))
                Es.append(float('nan'))
                ks.append(float(coeff_set.find('k').text))

    reaction_dict['A'] = np.array(As)
    reaction_dict['b'] = np.array(bs)
    reaction_dict['E'] = np.array(Es)
    reaction_dict['k'] = np.array(ks)
    reaction_dict['coeftype'] = np.array(rxn_types)

    # Get the reactants for the 'vprime' matrix and arrange the vprime matrix
    vprime = np.zeros((len(species_list), len(reactions_list)))
    reaction_count = 0

    for reaction_data in chemical_reactions.find('reactionData').findall('reaction'):
        # Find the reactants data
        reactants_text = reaction_data.find('reactants').text

        # Split the data
        for specie_concentration in reactants_text.split(' '):

            # Get the name of the specie and its concentration
            specie = specie_concentration.split(':')[0]
            concentration = float(specie_concentration.split(':')[1])
            vprime[species_list.index(specie)][reaction_count] = concentration # Update at the index

        # Move to the next equation
        reaction_count += 1

    reaction_dict['vprime'] = np.array(vprime)

    # Get the reactants for the 'vprime' matrix and arrange the vprime matrix
    v2prime = np.zeros((len(species_list), len(reactions_list)))
    reaction_count = 0

    for reaction_data in chemical_reactions.find('reactionData').findall('reaction'):

        # Find the reactants data
        products_text = reaction_data.find('products').text

        # Split the data
        for specie_concentration in products_text.split(' '):

            # Get the name of the specie and its concentration
            specie = specie_concentration.split(':')[0]
            concentration = float(specie_concentration.split(':')[1])
            v2prime[species_list.index(specie)][reaction_count] = concentration  # Update at the index

        # Move to the next equation
        reaction_count += 1

    reaction_dict['v2prime'] = np.array(v2prime)

    return reaction_dict