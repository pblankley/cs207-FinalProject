
import numpy as np
from functools import reduce


class Reaction:
    """
    This class represents the entire reaction for a set of elementary reactions.
    The class takes in a dictionary of parameters generated by the parser method.
    
    This dictionary contains a matrix vprime and a matrix v2prime corresponsing to 
    the usual v' and v'' matrices in systems of elementary reactions, v' being reactants 
    and v'' being reactands.  
    
    The dictionary also contains lists (length corresponding to the columns of v' and v'')
    with the values for A,b,E,k and coeftype for each elementary reaction in the system. NOTE: If one 
    or more of these parameters is rendered usless or NA for a reaction it is given the 
    value NaN. Coeftype is a list of strings containing the type of reaction.
    
    ----------
    Args: param_dict; where param_dict is the output from the parser function.
    
    ----------
    Methods: 
        reaction_coef(Temperature); Returns the 'k' reaction coefficients for 
                                    each reaction in the system
        
        progress_rate(x, T); where x is the vector of concentrations of the system and 
                            T is the temperature the system of reactions occurs at. Returns
                            the 'w' progress rate for each reaction in the system.
        
        reaction_rate(x, T); where x is the vector of concentrations of the system and 
                            T is the temperature the system of reactions occurs at. Returns
                            the 'f' reaction rate for each reaction in the system.
        set_params(idx, **kwargs); where you specify idx to be the index of the reaction 
                            you want to change the parameters for and the keyword 
                            indicates the parameter you want to change. 
                            Options to change are: {A,b,E,R,k,coeftype}
    =========
    Examples:
    # Example with the reaction rate
        
    >>> vp = np.array([[1.,2.],[2.,0.],[0.,2.]])
    >>> vpp = np.array([[0.,0.],[0.,1.],[2.,1.]])
    >>> pdict = {'vprime': vp, 'v2prime': vpp, 'A': [float('nan'),float('nan')], \
                'b': [float('nan'),float('nan')], 'E': [float('nan'),float('nan')], \
                'k': [10,10], 'coeftype': ['Constant','Constant']}
    >>> rrr = Reaction(pdict)
    >>> rrr.reaction_rate(np.array([[1.],[2.],[1.]]),10)
    [-60.0,-70.0,70.0]
    
    # Example with the progress rate 
    
    >>> vp = np.array([[1.,2.],[2.,0.],[0.,2.]])
    >>> vpp = np.array([[0.,0.],[0.,1.],[2.,1.]])
    >>> pdict = {'vprime': vp, 'v2prime': vpp, 'A': [float('nan'),float('nan')], \
                'b': [float('nan'),float('nan')], 'E': [float('nan'),float('nan')], \
                'k': [10,10], 'coeftype': ['Constant','Constant']}
    >>> rrr = Reaction(pdict)
    >>> rrr.progress_rate(np.array([[1.],[2.],[1.]]),10)
    [40.0,10.0]
    
    # Example with reaction coef 
    >>> vp = np.array([[1.,2.],[2.,0.],[0.,2.]])
    >>> vpp = np.array([[0.,0.],[0.,1.],[2.,1.]])
    >>> pdict = {'vprime': vp, 'v2prime': vpp, 'A': [.00045,.00045], \
                'b': [1.2,1.2], 'E': [1.7,1.7], \
                'k': [float('nan'),float('nan')], 'coeftype': ['Arrhenius','modifiedArrhenius']}
    >>> rrr = Reaction(pdict)
    >>> rrr.reaction_coef(900)
    [0.00044989777442266471, 1.5783556022951033]
    
    # Example with set params
    >>> vp = np.array([[1.,2.],[2.,0.],[0.,2.]])
    >>> vpp = np.array([[0.,0.],[0.,1.],[2.,1.]])
    >>> pdict = {'vprime': vp, 'v2prime': vpp, 'A': [.00045,.00045], \
                'b': [1.2,1.2], 'E': [1.7,1.7], \
                'k': [float('nan'),float('nan')], 'coeftype': ['Arrhenius','modifiedArrhenius']}
    >>> rrr = Reaction(pdict)
    >>> rrr.reaction_coef(900)
    >>> rrr.set_params(1,k=10)
    >>> rrr.reaction_coef(900)
    [0.00044989777442266471, 10]
    
    
    
    
    """
    def __init__(self, param_dict):
        self.vprime = param_dict['vprime']
        self.v2prime = param_dict['v2prime']
        
        # Check for equal shapes in v' and v''
        if self.vprime.shape!=self.v2prime.shape:
            raise ValueError('The vprime and v2prime matrices must be the same size.')
        
        # Make sure every parameter for A,b,E,k comes in as a float
        try: 
            self.A = [float(a) for a in param_dict['A']]
            self.b = [float(i) for i in param_dict['b']]
            self.E = [float(e) for e in param_dict['E']]
            self.k = [float(j) for j in param_dict['k']]
            self.R = [8.314 for i in range(len(param_dict['A']))]
        except (TypeError, ValueError) as err:
                if type(err) == ValueError:
                    raise ValueError('You must input a numeric, real number data type for all parameters.')
                raise TypeError('You must input a real number. Hint: you may have put in a list.')
        
        # All A values must be ge 0
        if any(a<=0 for a in self.A):
            raise ValueError('Your A values should be strictly positive. They were {self.A}.')
        
        # Validate input model types
        valid_types = ['modifiedArrhenius','Arrhenius','Constant']
        if all(pt in valid_types for pt in param_dict['coeftype']):
            self.coeftypes = param_dict['coeftype']
        else:
            raise ValueError("Your input file gave, {param_dict['coeftype']}, not valid reaction coefficients type.")
    
    
    
    def reaction_coef(self, T):
        """Set reaction coefficients for the given float T and mt (model type).
        -------
        Args: T; float; the temperature for all reactions
              mt; list of strings, the model types for each part of the reaction
        -------
        Returns: None
        -------
        Raises: ValueError when T cannot be cast to a float or T is negative 
        """
        try:
            temp = float(T)
        except (TypeError, ValueError) as err:
            raise err('Your value for temp must be a float, not {T}')
        
        if temp < 0:
            raise ValueError('Your T value should be positive. It was {temp}.')
            
        for i,mt in enumerate(self.coeftypes):
            if mt == 'Constant':
                pass
            elif mt == 'Arrhenius':
                self.k[i] = self._arrhenius(i,temp)
            else: 
                self.k[i] = self._mod_arrhenius(i,temp)
        return self.k
        
        
    def progress_rate(self, x, T):
        """ This function calculates the progress rate of a reaction of the following form:
                    V'11*A + V'21*B -> V''31*C
                V'12*A + V'32*C -> V''22*B + V''32*C
        It taken in the vectors v', v'' and x in the order [[A],[B],[C]].
        -------
        Args: v',v'', matrices, numpy arrays of form mxn where m is the number of reactants and n is number of equations.
              x; vector, numpy array (or list of lists) of length equal to the number of reactants in the system of equations.
              k; float or list of length n (number of equations), the k constant in the reaction of elementary equations.
        -------
        Returns: list of floats; the progress rate of the reaction for each equation
        -------
        Raises: ValueError if the shapes of the v matrices are not equal and if the x vector is not mx1
        =======
        Examples:
        >>> vp = np.array([[1.,2.],[2.,0.],[0.,2.]])
        >>> vpp = np.array([[0.,0.],[0.,1.],[2.,1.]])
        >>> x = np.array([[1.],[2.],[1.]])
        >>> progress_rate(vp,vpp,x,10)
        [40.0, 10.0]
        """
        m,n = self.vprime.shape
        if x.shape != (m,1):
            raise ValueError('The x vector must be the same as your v matrices, but it was {1}'.format(x.shape))
        
        try:
            temp = float(T)
        except (TypeError, ValueError) as err:
            raise err('Your value for temp must be a float, not {T}')
        
        if temp < 0:
            raise ValueError('Your T value should be positive. It was {temp}.')
            
        k = self.reaction_coef(temp)
        w = []
        for j in range(n):
            w.append(k[j]*reduce((lambda x,y: x*y),np.power(x.T[0],self.vprime.T[j])))
        self.w = w
        return w
    
    
    def reaction_rate(self,x,T):
        """ This function calculates the reaction rate of a reaction of the following form:
                    V'11*A + V'21*B -> V''31*C
                    V'32*C -> V'12*A + V''22*B
        It taken in the vectors v', v'' from the class and x in the order [[A],[B],[C]].
        -------
        Args: x; vector, numpy array (or list) of length equal to the number of 
                    reactants in the system of equations.
              T; float, the strictly positive temperature 
        -------
        Returns: vector of floats; the reaction rate for each equation
        -------
        Raises: ValueError when temp is less than 0 or x is not (mx1)
        =======
        Example:
        >>> x = np.array([[1.],[2.],[1.]])
        >>> reaction_rate(vp,vpp,x,10)
        [-30.0, -60.0, 20.0]
    
        """
        m,n = self.vprime.shape

        if x.shape != (m,1):
            raise ValueError('The x vector must be the same height as your v matrices, but it was {x.shape[0]}')
        
        try:
            temp = float(T)
        except (TypeError, ValueError) as err:
            raise ValueError('Your value for temp must be a float, not {T}')
        
        if temp < 0:
            raise ValueError('Your T value should be positive. It was {temp}.')
            
        w = self.progress_rate(x,T)
        v = self.v2prime - self.vprime
        f = []
        for i in range(m):
            f.append(sum([v[i][j]*w[j] for j in range(n)]))
        return f
    
    def _arrhenius(self, idx, T):
        """ This function takes in the parameter T (kelvin temperature)
        from the class attributes, and it will return a value, k, that is the 
        Arrhenius reaction rate coefficient.
        ---------
        Args: T, float; temperature, (gets args from class)
        ---------
        Returns: The float k where k is the reaction rate coefficient.
        ---------
        Raises: OverflowError after constant evaluation
                FloatingPointError after constant evaluation for underflow
        """
        k = self.A[idx]*np.exp(-self.E[idx]/(self.R[idx]*T))
        if k == float('inf'):
            raise OverflowError('overflow error in evalutation of constant')
        if k <= np.finfo(float).eps:
            raise FloatingPointError('underflow error in evalutation of constant')
        return k

    def _mod_arrhenius(self, idx, T):
        """ This function takes in the parameter T (kelvin temperature)
        from the class attributes, and it will return a value, k, that is the 
        modified Arrhenius reaction rate coefficient.
        ---------
        Args: T, float; temperature (gets args from class)
        ---------
        Returns: The float k where k is the reaction rate coefficient.
        ---------
        Raises: OverflowError after constant evaluation
                FloatingPointError after constant evaluation for underflow
        """
        k = self.A[idx]*(T**self.b[idx])*np.exp(-self.E[idx]/(self.R[idx]*T))
        if k == float('inf'):
            raise OverflowError('overflow error in evalutation of constant')
        if k <= np.finfo(float).eps:
            raise FloatingPointError('underflow error in evalutation of constant')
        return k

    def set_params(self,idx,A=None,b=None,E=None,R=None, k=None, coeftype=None):
        """ This function takes inputs of the parameters you want to set for 
        reaction coefficient calculation 
        -------
        Args: A,b,E,T,R; all floats and optional arguments
        -------
        Returns: None
        -------
        Raises: ValueError when any input given a value other than None cannot 
            be cast to a float
        """
        if type(A) != type(None):
            try:
                self.A[idx] = float(A)
            except (TypeError, ValueError) as err:
                if type(err) == ValueError:
                    raise ValueError('Your input  for A was not a numeric, real number.')
                raise TypeError('You must input a real number for A. Hint: you may have put in a list.')
        
        if type(b) != type(None):
            try:
                self.b[idx] = float(b)
            except (TypeError, ValueError) as err:
                if type(err) == ValueError:
                    raise ValueError('Your input  for b was not a numeric, real number.')
                raise TypeError('You must input a real number for b. Hint: you may have put in a list.')
    
        if type(E) != type(None):
            try:
                self.E[idx] = float(E)
            except (TypeError, ValueError) as err:
                if type(err) == ValueError:
                    raise ValueError('Your input  for E was not a numeric, real number.')
                raise TypeError('You must input a real number for E. Hint: you may have put in a list.')

        if type(R) != type(None):
            try:
                self.R[idx] = float(R)
            except (TypeError, ValueError) as err:
                if type(err) == ValueError:
                    raise ValueError('Your input  for R was not a numeric, real number.')
                raise TypeError('You must input a real number for R. Hint: you may have put in a list.')
    
        if type(k) != type(None):
            try:
                self.k[idx] = float(k)
            except (TypeError, ValueError) as err:
                if type(err) == ValueError:
                    raise ValueError('Your input  for R was not a numeric, real number.')
                raise TypeError('You must input a real number for R. Hint: you may have put in a list.')
    
        if type(coeftype) != type(None):
            if coeftype in ['modifiedArrhenius','Arrhenius','Constant']:
                self.coeftypes[idx] = coeftype
            else:
                raise ValueError('Your input for coeftype was {coeftype}, not an available option')




            

    